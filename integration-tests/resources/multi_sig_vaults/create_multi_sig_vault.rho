new
  rl(`rho:registry:lookup`), MultiRevVaultCh,
  stdout(`rho:io:stdout`), log
in {
    new RevVaultCh, MultiSigRevVaultCh in {
              rl!(`rho:rchain:revVault`, *RevVaultCh) |
              rl!(`rho:rchain:multiSigRevVault`, *MultiSigRevVaultCh) |
              for (@(_, RevVault) <- RevVaultCh; @(_, MultiSigRevVault) <- MultiSigRevVaultCh) {
                ret!((RevVault, MultiSigRevVault))
              }
            }
     new genesisVaultCh, carolAuthCh, carolVaultCh, ret, retOk  in {
      withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
      @MultiSigRevVault!("makeSealerUnsealer", *carolAuthCh) |
      for (@(_, carolUnsealer) <- carolAuthCh) {
        // Single sig as a special case of multisig.
        @MultiSigRevVault!("create", [], [carolUnsealer], 1, *carolVaultCh) |
        for (genesisVault, @genesisVaultKey <- genesisVaultCh; @maybeVault <- carolVaultCh) {
          match maybeVault {
            (false, msg) => {
              rhoSpec!("assert", (false, "==", true), msg, *ackCh)
            }
            (true, (carolMultiSigVault, carolRevAddr, carolRevVault)) => {
              // 9000000 - 1000 = 8999000
              genesisVault!("transfer", carolRevAddr, 1000, genesisVaultKey, *ret) |
              rhoSpec!("assert", ((true, Nil), "== <-", *ret), "transfer successful", *ackCh) |
              assertBalances!(*retOk, [(*genesisVault, 8999000), (carolMultiSigVault, 1000)], *rhoSpec, *ackCh)
            }
          }
        }
      }
    }
}
